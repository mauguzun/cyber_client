<div id="map" style="border:1px solid red; height:100vh;">
  <div class="google-map-address">
    <h4 v-on:click="openAuto('start')">
      <span> {{ start }} </span>
    </h4>
    <h4 v-on:click="openAuto('stop')">
      <span> {{ stop }} </span>
    </h4>

    <div class="alert text-light bg-dark">
      <a
        href="#"
        class="close"
        data-dismiss="alert"
        aria-label="close"
        title="close"
        >×</a
      >
      <strong>{{ trans.map.texts.blocks.warning }}</strong>
    </div>
  </div>

  <!--Order card-->
  <!-- <div class="google-map-complete over" v-if="Order != null"> -->
  <div
    class="google-map-complete over"
    v-if="MapOrder != null && MapOrder.price != null "
  >
    <div class="card" style="width: 100%;height: 100vh;">
      <div class="card-body">
        <h5 class="card-title">{{ trans.order.input.attr.value.order }}</h5>

        <ul class="list-group list-group-flush">
          <li class="list-group-item">
            <span class="badge badge-secondary">{{
              trans.order.texts.title.start
            }}</span
            >{{ MapOrder.start }}
          </li>
          <li class="list-group-item">
            <span class="badge badge-secondary">{{
              trans.order.texts.title.stop
            }}</span
            >{{ MapOrder.stop }}
          </li>
          <li class="list-group-item">
            <span class="badge badge-secondary">{{
              trans.order.texts.title.price
            }}</span
            >{{ MapOrder.price }} EUR
          </li>
          <li class="list-group-item">
            <span class="badge badge-secondary">{{
              trans.order.texts.title.period
            }}</span
            >{{ (MapOrder.duration / 60).toFixed(2) }} <strong>min</strong>
          </li>
          <li class="list-group-item">
            <span class="badge badge-secondary">{{
              trans.order.texts.title.await
            }}</span
            >{{ MapOrder.driver_await }}
          </li>
          <li class="list-group-item">
            <span class="badge badge-secondary">
              {{ trans.order.texts.title.distance }}</span
            >{{ (MapOrder.distance / 1000).toFixed(2) }} <strong>km</strong>
          </li>
        </ul>
        <a href="#" @click="MakeOrder()" class="btn btn-primary">
          {{ trans.order.input.attr.value.order }}</a
        >

        <p class="card-text">{{ trans.order.texts.block.important }}</p>
        <br />
        <a
          @click="MapOrder = null "
          class="close"
          data-dismiss="alert"
          aria-label="close"
          title="close"
          >×</a
        >
      </div>
    </div>
  </div>
  <!--Order card-->
  <div v-show="edit" class="google-map-complete">
    <i class="fa fa-times" @click="edit = null " aria-hidden="true"></i>

    <div class="form-field">
      <input
        type="search"
        v-model="edit"
        id="autoAddress"
        class="form-control"
      />
    </div>
  </div>

  <div class="google-map-order" v-show="points.stop">
    <button
      type="button"
      @click="GetDirections()"
      class="btn btn-danger btn-lg btn-block"
    >
      {{ buttonInfo }}
    </button>
  </div>

  <div id="gmap" style="position:relative;height:100vh"></div>
</div>
<script>

  
  let vueGmap = new Vue({
    el: "#map",
    data: {
      trans: trans,
      buttonInfo: trans.map.links.order,
      points: {
        start: null,
        stop: null
      },
      MapOrder: null,
      marker: {},
      map: null,
      drivers: [],
      distance: null,
      duration: null,
      polyline: null,
      edit: null,
      start: trans.map.input.attr.placeholder.start,
      stop: trans.map.input.attr.placeholder.stop
    },
    methods: {
      init() {
        this.map = new google.maps.Map(document.getElementById("gmap"), {
          center: this.points.start.location,
          zoom: 17,
          disableDefaultUI: true
        });
        this.initmarker();
        this.SetDriverOnMap();
      },

      initmarker() {
        this.marker.start = new google.maps.Marker({
          map: this.map,
          position: this.points.start,
          draggable: true,
          icon: "img/icon.png"
        });
        this.marker.stop = new google.maps.Marker({
          map: this.map,
          draggable: true,
          icon: "img/icon.png"
        });

        this.LocationByMarker("start");
        this.map.setCenter(this.points.start);
        let self = this;
        for (const key in this.marker) {
          google.maps.event.addListener(this.marker[key], "dragend", function(
            event
          ) {
            let location = { lat: event.latLng.lat(), lng: event.latLng.lng() };
            self.points[key] = location;
            self.LocationByMarker(key);
          });
        }
      },

      LocationByMarker(key) {
        let self = this;
        this.geocoder = this.geocoder || new google.maps.Geocoder();
        this.geocoder.geocode({ location: self.points[key] }, function(
          results,
          status
        ) {
          if (status === "OK" && results[0]) {
            self.SetAddress(key, results[0].formatted_address);
          }
        });
      },

      SetDriverOnMap() {
        for (var i = 0; this.drivers[i]; i++) {
          this.drivers[i].setMap(null);
        }

        // clear old driver
        Api.PostData("/driver", this.points.start).then(e => {
          if (e.action === true) {
            e.points.forEach(element => {
              let driver = new google.maps.Marker({
                map: this.map,
                position: element,
                icon: "img/car.png"
              });
              this.drivers.push(driver);
            });
          }
        });
      },
      MakeOrder() {
        
        ManageOrder.OrderAssing(this.MapOrder);
        ManageOrder.SendOnServer();
        ManageOrder.RedirectByStatus();
      },
      SetupAuto(edit) {
       
        var autocomplete = new google.maps.places.Autocomplete(
          document.getElementById("autoAddress")
        );
        autocomplete.bindTo("bounds", this.map);
        autocomplete.setFields([
          "address_components",
          "geometry",
          "icon",
          "name"
        ]);

        var bindTo = edit;
        var self = this;

        autocomplete.addListener("place_changed", function() {
          var place = autocomplete.getPlace();
          if (!place.geometry) {
            return;
          }

          if (place.geometry.viewport) {
            self.map.fitBounds(place.geometry.viewport);
          } else {
            self.map.setCenter(place.geometry.location);
          }

          let address = "";
          if (place.address_components) {
            address = [
              (place.address_components[0] &&
                place.address_components[0].short_name) ||
                "",
              (place.address_components[1] &&
                place.address_components[1].short_name) ||
                "",
              (place.address_components[2] &&
                place.address_components[2].short_name) ||
                ""
            ].join(" ");
          }

          self.points[bindTo] = {
            lat: place.geometry.location.lat(),
            lng: place.geometry.location.lng()
          };

          self[bindTo] = `${address} `;
          self.SetMarker(bindTo);
          self.edit = null;
        });
      },

      openAuto(key) {
        this.edit = this[key];
        //this.map.setCenter(this.points[key].location);
        this.SetupAuto(key);
      },

      SetAddress(key, val) {
        this[key] = val;
      },

      SetMarker(arg) {
        this.marker[arg].setPosition(this.points[arg]);
        if (arg == "start") {
          this.SetDriverOnMap();
        }
      },

      GetDirections() {

        if(!ManageOrder.Finished()){
          ManageOrder.RedirectByStatus();
        }
        var self = this;
        let directionsService = new google.maps.DirectionsService();

        directionsService.route(
          {
            origin: `${this.points.start.lat},${this.points.start.lng}`,
            destination: `${this.points.stop.lat},${this.points.stop.lng}`,
            travelMode: "DRIVING", //BICYCLING
            drivingOptions: {
              departureTime: new Date(/* now, or future date */),
              trafficModel: "optimistic"
            }
          },
          function(response, status) {
            if (status === "OK") {
              self.MapOrder = Order;
              self.MapOrder.distance = 0;
              self.MapOrder.duration = 0;
              self.MapOrder.polyline = response.routes[0].overview_polyline;
              self.MapOrder.start = self.start;
              self.MapOrder.stop = self.stop;

              const legs = response.routes[0].legs;
              for (var i = 0; i < legs.length; ++i) {
                self.MapOrder.distance += legs[i].distance.value;
                self.MapOrder.duration += legs[i].duration.value;
              }

              const sendData = {
                distance: self.MapOrder.distance,
                duration: self.MapOrder.duration,
                address: self.start
              };

              Api.PostData("price", sendData).then(result => {
                if (result.action === true) {
                  self.MapOrder.points = self.points;
                  self.MapOrder.price = result.data.price;
                  self.MapOrder.driver_await = result.data.driver_await;
                } else {
                  self.buttonInfo = trans.gmap.texts.error;
                }
              });
            } else {
              self.buttonInfo = trans.gmap.texts.error;
            }
          }
        );
      }
    },
    mounted: function() {
      const getCurrentPosition = function() {
        if (navigator.geolocation) {
          return new Promise((resolve, reject) =>
            navigator.geolocation.getCurrentPosition(resolve, reject, {
              enableHighAccuracy: true
            })
          );
        } else {
          return new Promise(resolve => resolve({}));
        }
      };

      getCurrentPosition()
        .then(done => {
          this.points.start = {
            lat: done.coords.latitude,
            lng: done.coords.longitude
          };
        })
        .catch(error => {
          console.log(error);
        })
        .finally(e => {
          this.init();
        });
    }
  });
</script>

<style>
  .google-map-address {
    position: absolute;
    width: 100%;
    z-index: 99;
    padding: 10px;
  }
  .google-map-address h4 {
    cursor: pointer;
    font-size: 20px;
    text-shadow: 1px 1px 5px #fff;
  }
  .google-map-complete {
    position: absolute;
    width: 100%;
    z-index: 199;
    padding: 10px;
    background-color: rgba(255, 255, 255, 0.9);
    height: 100vh;
  }

  .google-map-order {
    position: absolute;
    width: 100%;
    z-index: 288;
    padding: 1px;
    bottom: 5px;
  }
  .over {
    z-index: 400 !important;
  }
</style>
